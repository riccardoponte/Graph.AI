<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Graph.AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.1.0",
    "react-dom/client": "https://esm.sh/react-dom@^19.1.0/client",
    "@google/genai": "https://esm.sh/@google/genai",
    "html2canvas": "https://esm.sh/html2canvas@^1.4.1",
    "react-dom/": "https://esm.sh/react-dom@^19.1.0/",
    "react/": "https://esm.sh/react@^19.1.0/"
  }
}
</script>
  </head>
  <body class="bg-gray-100">
    <div id="root"></div>
    <script type="module">
      import React, { useState, useCallback, useRef, useMemo, useEffect } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI } from '@google/genai';
      import html2canvas from 'html2canvas';

      // --- ICONS ---
      const LogoIcon = () => React.createElement("svg", { width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, React.createElement("path", { d: "M22 16C22 19.3137 19.3137 22 16 22C12.6863 22 10 19.3137 10 16C10 12.6863 12.6863 10 16 10C19.3137 10 22 12.6863 22 16Z", stroke: "white", strokeWidth: "2" }), React.createElement("path", { d: "M16 22V28", stroke: "white", strokeWidth: "2", strokeLinecap: "round" }), React.createElement("path", { d: "M16 10V4", stroke: "white", strokeWidth: "2", strokeLinecap: "round" }), React.createElement("path", { d: "M10 16H4", stroke: "white", strokeWidth: "2", strokeLinecap: "round" }), React.createElement("path", { d: "M28 16H22", stroke: "white", strokeWidth: "2", strokeLinecap: "round" }), React.createElement("path", { d: "M19.5356 19.5355L23.0711 23.071", stroke: "white", strokeWidth: "2", strokeLinecap: "round" }), React.createElement("path", { d: "M8.92891 8.92891L12.4644 12.4644", stroke: "white", strokeWidth: "2", strokeLinecap: "round" }), React.createElement("path", { d: "M19.5356 12.4644L23.0711 8.92891", stroke: "white", strokeWidth: "2", strokeLinecap: "round" }), React.createElement("path", { d: "M8.92891 23.071L12.4644 19.5355", stroke: "white", strokeWidth: "2", strokeLinecap: "round" }), React.createElement("circle", { cx: "16", cy: "16", r: "2", fill: "white" }));
      const UploadIcon = () => React.createElement("svg", { className: "mx-auto h-12 w-12 text-gray-400", stroke: "currentColor", fill: "none", viewBox: "0 0 48 48", "aria-hidden": "true" }, React.createElement("path", { d: "M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }));
      const DataIcon = () => React.createElement("svg", { className: "mx-auto h-12 w-12 text-gray-400", fill: "none", viewBox: "0 0 48 48", stroke: "currentColor", "aria-hidden": "true" }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 17v-2m3 2v-4m3 4v-6m2-4H7a2 2 0 00-2 2v16a2 2 0 002 2h16a2 2 0 002-2V7a2 2 0 00-2-2h-4.586a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 0012.586 3H11a1 1 0 00-1 1v1z"}));
      const DownloadIcon = () => React.createElement("svg", { className: "h-5 w-5", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" }));
      const SaveIcon = () => React.createElement("svg", { className: "h-5 w-5", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 13l4 4L19 7" }));
      const EditIcon = () => React.createElement("svg", { className: "h-6 w-6", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.5L16.732 3.732z" }));
      const ViewIcon = () => React.createElement("svg", { className: "h-6 w-6", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z" }), React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" }));
      const CloseIcon = () => React.createElement("svg", { className: "h-6 w-6", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }));
      const CloseEditorIcon = () => React.createElement("svg", { className: "h-5 w-5", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M10 19l-7-7m0 0l7-7m-7 7h18" }));
      const DeleteIcon = () => React.createElement("svg", { className: "h-6 w-6", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" }));
      const CombineIcon = () => React.createElement("svg", { className: "h-5 w-5", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" }));
      const LoadingSpinner = ({ className = '' }) => React.createElement("svg", { className: `animate-spin h-8 w-8 text-red-600 ${className}`, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" }, React.createElement("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), React.createElement("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" }));
      const SparklesIcon = () => React.createElement("svg", { className: "h-5 w-5", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M10 21l-3-3m0 0l-3-3m3 3l3-3m-3 3l3 3M14 3l3 3m0 0l3 3m-3-3l-3 3m3-3l-3-3m6 11.5a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5zM3 11.5a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5z" }));
      const NewPaintBucketIcon = () => React.createElement("svg", { className: "h-5 w-5 text-gray-700", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor" }, React.createElement("path", { d: "M3.143 4.522a1.25 1.25 0 011.06-.522h11.602a1.25 1.25 0 011.054.516l.89 1.484a.625.625 0 01-.529 1.004H2.782a.625.625 0 01-.528-1.004l.889-1.484z" }), React.createElement("path", { fillRule: "evenodd", d: "M3.81 9.065a.625.625 0 01.618.533l.403 2.296.143.815c.13.738.745 1.291 1.49 1.291h7.072c.745 0 1.36-.553 1.49-1.29l.143-.815.402-2.296a.625.625 0 01.618-.533h.25a.625.625 0 01.533.618l-.403 2.296-.143.815a2.75 2.75 0 01-2.73 2.457H6.05a2.75 2.75 0 01-2.73-2.456l-.143-.815-.402-2.296a.625.625 0 01.533-.618h.25z", clipRule: "evenodd" }));
      const PngIcon = () => React.createElement("svg", { className: "h-5 w-5", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor"}, React.createElement("path", { strokeLinecap:"round", strokeLinejoin:"round", strokeWidth:2, d:"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l-1-1a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" }));
      const SvgIcon = () => React.createElement("svg", { className: "h-5 w-5", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor"}, React.createElement("path", { strokeLinecap:"round", strokeLinejoin:"round", strokeWidth:2, d:"M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" }));
      const CommentIcon = () => React.createElement("svg", { className: "h-5 w-5", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor"}, React.createElement("path", { fillRule:"evenodd", d:"M10 2a8 8 0 100 16 8 8 0 000-16zM2 10a8 8 0 1116 0 8 8 0 01-16 0zm7.25-2.75a.75.75 0 00-1.5 0v4.5a.75.75 0 001.5 0v-4.5zM10 12.25a.75.75 0 000 1.5h.01a.75.75 0 000-1.5H10z", clipRule:"evenodd"}));
      const DataIconSvgString = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.375 19.5h17.25m-17.25 0a1.125 1.125 0 01-1.125-1.125M3.375 19.5v-1.5M1.125 6.75v11.25c0 .621.504 1.125 1.125 1.125h17.25c.621 0 1.125-.504 1.125-1.125V6.75m-19.5 0a1.125 1.125 0 011.125-1.125h17.25c.621 0 1.125.504 1.125 1.125m-19.5 0v-1.5c0-.621.504-1.125 1.125-1.125h17.25c.621 0 1.125.504 1.125 1.125v1.5m-6.375 0v-1.5a1.125 1.125 0 00-1.125-1.125H10.5a1.125 1.125 0 00-1.125 1.125v1.5" /></svg>';

      // --- UTILS ---
      const wrapHtmlForIframe = (htmlContent) => {
        if (!htmlContent) return '';
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlContent, 'text/html');
        let bodyContent = doc.body.innerHTML;

        const styleTag = doc.head.querySelector('style');
        const scriptTag = doc.head.querySelector('script');
        
        let headContent = '';
        if (styleTag) headContent += styleTag.outerHTML;
        if (scriptTag) headContent += scriptTag.outerHTML;

        headContent += `
          <style>
            /* Robust scrolling for oversized content */
            html, body {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
            }
            body {
              overflow: auto; /* The key property: add scrollbars IF needed */
              padding: 1rem; /* A little space is nice */
            }
          </style>
        `;
        return `<!DOCTYPE html><html><head>${headContent}</head><body>${bodyContent}</body></html>`;
      };

      // --- DOWNLOADER ---
      function createDownloadLink(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      const downloadHtml = (htmlContent, filename) => {
        if (!htmlContent) {
          alert("Nessun contenuto disponibile per il download.");
          return;
        }
        const blob = new Blob([htmlContent], { type: 'text/html' });
        createDownloadLink(blob, filename);
      };
      const downloadCombinedHtml = (artworks, filename) => {
        const bodyContent = artworks.map((art) => {
            const escapedContent = art.htmlContent.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return `
              <section class="artwork-section">
                <h2 class="section-title">${art.title}</h2>
                <iframe srcdoc="${escapedContent}" class="artwork-iframe" sandbox="allow-scripts" loading="lazy"></iframe>
              </section>
            `;
        }).join('');
        const fullHtml = `
          <!DOCTYPE html>
          <html lang="it">
            <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Creazioni Combinate</title>
              <style>
                html { scroll-behavior: smooth; }
                body {
                  background-color: #e5e7eb;
                  color: #1f2937;
                  font-family: sans-serif;
                  margin: 0;
                  scroll-snap-type: y mandatory;
                }
                .artwork-section {
                  width: 100vw;
                  height: 100vh;
                  display: flex;
                  flex-direction: column;
                  align-items: center;
                  justify-content: center;
                  scroll-snap-align: start;
                  box-sizing: border-box;
                  padding: 2rem;
                  border-bottom: 2px solid #d1d5db;
                }
                .section-title {
                  font-size: 1.5rem;
                  font-weight: bold;
                  margin-bottom: 1rem;
                  text-align: center;
                }
                .artwork-iframe {
                  width: 100%;
                  height: 100%;
                  border: 1px solid #d1d5db;
                  border-radius: 0.5rem;
                  background-color: white;
                }
              </style>
            </head>
            <body>${bodyContent}</body>
          </html>
        `;
        const blob = new Blob([fullHtml], { type: 'text/html' });
        createDownloadLink(blob, filename);
      };

      // --- AI & FILE PROCESSING ---
      const fileToGenerativePart = async (file) => {
        const base64EncodedDataPromise = new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            if (reader.result) {
              resolve(reader.result.split(',')[1]);
            } else {
              reject(new Error("Lettura del file non riuscita."));
            }
          };
          reader.onerror = (err) => reject(err);
          reader.readAsDataURL(file);
        });
        return { inlineData: { data: await base64EncodedDataPromise, mimeType: file.type } };
      };
      
      const readFileAsText = (file) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            if (typeof reader.result === 'string') {
              resolve(reader.result);
            } else {
              reject(new Error("Lettura del file come testo non riuscita."));
            }
          };
          reader.onerror = (err) => reject(err);
          reader.readAsText(file);
        });
      };
      
      const fileToDataUrl = (file) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            if (reader.result) {
              resolve(reader.result);
            } else {
              reject(new Error("Lettura del file per data URL non riuscita."));
            }
          };
          reader.onerror = (err) => reject(err);
          reader.readAsDataURL(file);
        });
      };
      
      const processApiResponse = (response) => {
        let htmlContent = response.text.trim();
        const fenceRegex = /^\`\`\`html\s*\n?(.*?)\n?\s*\`\`\`$/s;
        const match = htmlContent.match(fenceRegex);
        if (match && match[1]) {
          htmlContent = match[1].trim();
        } else if (!htmlContent.trim().toLowerCase().startsWith('<!doctype html>')) {
          console.error("Raw response from AI:", response.text);
          throw new Error("La risposta dell'IA non era nel formato HTML previsto.");
        }
        return htmlContent;
      };

      const startImageChat = async (file) => {
        const apiKey = "AIzaSyAUpMnG760HSOV7rah2UwkOajoH3aD4OFs";
        if (!apiKey) throw new Error("Chiave API non trovata.");
        const ai = new GoogleGenAI({ apiKey: apiKey });
        const imagePart = await fileToGenerativePart(file);
        const dataUrl = await fileToDataUrl(file);
        const prompt = `AGISCI COME UN PROGRAMMATORE ESPERTO DI ANALISI DATI. (Definizione di “Ruolo”)
IN ALLEGATO TROVERAI UNA IMMAGINE DI UNA TABELLA EXCEL O DI UN GRAFICO (Definizione di “Contesto”)
IL TUO COMPITO E’ DI RIPRODURRE L’IMMAGINE CHE TROVI IN ALLEGATO COME UNA PRESENTAZIONE INTERATTIVA RIPRODUCENDO FEDELMENTE: I DATI, I COLORI ECC. MI RACCOMANDO NON MODIFICARE E NON ALTERARE NESSUN DATO. DEVE ESSERE UNA RAPPRESENTAZIONE INTERATTIVA FEDELE E COERENTE CON L’IMMAGINE IN ALLEGATO. (Definizione di “Regole”). Segui scrupolosamente i seguenti requisiti tecnici: ID per modifiche (es. data-editable-id="bar-q1"), attributo data-value, e uno script di aggiornamento dinamico con una funzione updateGraph(). Restituisci esclusivamente il codice HTML completo, racchiuso in un blocco markdown.`;
        const chat = ai.chats.create({ model: 'gemini-2.5-flash-preview-04-17', config: { temperature: 0.0 } });
        const response = await chat.sendMessage({ message: [{ text: prompt }, imagePart] });
        const htmlContent = processApiResponse(response);
        return { htmlContent, dataUrl, chat };
      };
      
      const startDataChat = async (fileContent, fileType) => {
        const apiKey = "AIzaSyAUpMnG760HSOV7rah2UwkOajoH3aD4OFs";
        if (!apiKey) throw new Error("Chiave API non trovata.");
        const ai = new GoogleGenAI({ apiKey: apiKey });
        const prompt = `Agisci come un esperto di data visualization. Ti fornisco dei dati in formato ${fileType}. Il tuo compito è creare il miglior grafico interattivo possibile per rappresentare questi dati.
        **Dati:**
        \`\`\`${fileType.toLowerCase()}
        ${fileContent}
        \`\`\`
        **Istruzioni:**
        1. Analizza i dati e scegli un tipo di grafico appropriato (preferibilmente a barre, a linee o a torta).
        2. Se i dati hanno intestazioni, usale per le etichette e il titolo del grafico.
        3. Genera un codice HTML completo che includa CSS e JavaScript, seguendo **tutti i requisiti tecnici** che conosci (data-editable-id, data-value, funzione updateGraph(), tooltip CSS).
        4. Restituisci esclusivamente il codice HTML completo nel formato markdown consueto.`;
        const chat = ai.chats.create({ model: 'gemini-2.5-flash-preview-04-17', config: { temperature: 0.1 } });
        const response = await chat.sendMessage({ message: prompt });
        const htmlContent = processApiResponse(response);
        const dataUrl = 'data:image/svg+xml;base64,' + btoa(DataIconSvgString);
        return { htmlContent, dataUrl, chat };
      };

      // --- COMPONENTS ---
      const Header = () => React.createElement("header", { className: "bg-red-600 sticky top-0 z-40 shadow-lg" }, React.createElement("div", { className: "container mx-auto px-4 sm:px-6 lg:px-8" }, React.createElement("div", { className: "flex items-center justify-between h-16" }, React.createElement("div", { className: "flex items-center space-x-3" }, React.createElement(LogoIcon, null), React.createElement("span", { className: "font-bold text-xl text-white" }, "Graph.AI")))));
      
      const InputUploader = ({ onFileUpload, isLoading }) => {
        const [mode, setMode] = useState('image'); // 'image' or 'data'
        const [file, setFile] = useState(null);
        const [fileName, setFileName] = useState('');
        const fileInputRef = useRef(null);

        const handleFileChange = (event) => {
            const selectedFile = event.target.files?.[0];
            if (selectedFile) {
                setFile(selectedFile);
                setFileName(selectedFile.name);
            }
        };

        const handleDrop = (event) => {
            event.preventDefault();
            event.stopPropagation();
            const droppedFile = event.dataTransfer.files?.[0];
            if (droppedFile) {
                const isImage = droppedFile.type.startsWith('image/');
                const isData = ['.csv', '.json'].some(ext => droppedFile.name.endsWith(ext));
                if ((mode === 'image' && isImage) || (mode === 'data' && isData)) {
                    setFile(droppedFile);
                    setFileName(droppedFile.name);
                } else {
                    alert(`File non valido per la modalità "${mode}".`);
                }
            }
        };
        const handleDragOver = (event) => { event.preventDefault(); event.stopPropagation(); };

        const handleSubmit = (event) => {
            event.preventDefault();
            if (file) { onFileUpload(file); }
        };
        
        const resetInput = () => {
            setFile(null);
            setFileName('');
            if(fileInputRef.current) fileInputRef.current.value = "";
        };

        const renderUploader = () => {
            const isImageMode = mode === 'image';
            const acceptedFiles = isImageMode ? "image/*" : ".csv, .json, text/csv, application/json";
            const promptText = isImageMode 
                ? "Trascina un'immagine, o fai clic per caricare" 
                : "Trascina un file CSV o JSON, o fai clic";
            const icon = isImageMode ? React.createElement(UploadIcon, null) : React.createElement(DataIcon, null);

            return React.createElement("form", { onSubmit: handleSubmit, className: "space-y-6" }, 
                React.createElement("div", null, 
                    React.createElement("label", { htmlFor: "file-upload", className: "relative block w-full border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-red-500 transition-colors", onDrop: handleDrop, onDragOver: handleDragOver }, 
                        React.createElement("div", { className: "flex flex-col items-center" }, 
                            icon, 
                            React.createElement("span", { className: "mt-2 block text-sm font-semibold text-gray-700" }, fileName || promptText), 
                            React.createElement("span", { className: "text-xs text-gray-500" }, isImageMode ? "PNG, JPG, GIF" : "CSV, JSON")
                        ), 
                        React.createElement("input", { ref: fileInputRef, id: "file-upload", name: "file-upload", type: "file", className: "sr-only", accept: acceptedFiles, onChange: handleFileChange })
                    )
                ), 
                React.createElement("button", { type: "submit", disabled: !file || isLoading, className: "w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 focus:ring-offset-gray-100 disabled:bg-red-400 disabled:cursor-not-allowed transition-all" }, 
                    isLoading ? 'Elaborazione in corso...' : 'Crea'
                )
            );
        };

        return React.createElement("div", { className: "w-full bg-white p-6 md:p-8 rounded-xl shadow-lg border border-gray-200" },
            React.createElement("div", { className: "mb-4 border-b border-gray-200" },
                React.createElement("nav", { className: "-mb-px flex space-x-6", "aria-label": "Tabs" },
                    React.createElement("button", { 
                        onClick: () => { setMode('image'); resetInput(); }, 
                        className: `whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm ${mode === 'image' ? 'border-red-500 text-red-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}`
                    }, "Da Immagine"),
                    React.createElement("button", { 
                        onClick: () => { setMode('data'); resetInput(); }, 
                        className: `whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm ${mode === 'data' ? 'border-red-500 text-red-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}`
                    }, "Da Dati (CSV/JSON)")
                )
            ),
            renderUploader()
        );
      };

      const FullScreenViewer = ({ artwork, onClose }) => {
        if (!artwork) return null;
        const iframeContent = useMemo(() => wrapHtmlForIframe(artwork.htmlContent), [artwork.htmlContent]);
        return React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4 transition-opacity duration-300", onClick: onClose, "aria-modal": "true", role: "dialog" }, React.createElement("div", { className: "relative w-full max-w-7xl h-[90vh] bg-white rounded-lg shadow-2xl flex flex-col", onClick: (e) => e.stopPropagation() }, React.createElement("div", { className: "flex justify-between items-center p-4 border-b border-gray-200" }, React.createElement("h3", { className: "text-lg font-bold text-gray-800 truncate", title: artwork.title }, artwork.title), React.createElement("button", { onClick: onClose, className: "p-2 text-gray-500 hover:text-red-600 rounded-full hover:bg-gray-100 transition-colors", "aria-label": "Chiudi visualizzazione" }, React.createElement(CloseIcon, null))), React.createElement("div", { className: "flex-grow w-full h-full rounded-b-lg overflow-hidden" }, React.createElement("iframe", { srcDoc: iframeContent, title: artwork.title, className: "w-full h-full border-0", sandbox: "allow-scripts" }))));
      };
      
      const ArtGallery = ({ artworks, onDelete, onRename, onView, onEdit, onReorder }) => {
        const [selectedIds, setSelectedIds] = useState(new Set());
        const [editingId, setEditingId] = useState(null);
        const [editingTitle, setEditingTitle] = useState('');
        const dragId = useRef(null);
        
        const handleSelect = (id) => setSelectedIds(prev => {
            const newSet = new Set(prev);
            newSet.has(id) ? newSet.delete(id) : newSet.add(id);
            return newSet;
        });

        const selectedArtworks = useMemo(() => {
            const selectedSet = new Set(selectedIds);
            return artworks.filter(art => selectedSet.has(art.id));
        }, [artworks, selectedIds]);

        const handleCombineAndDownload = () => { if (selectedArtworks.length > 0) downloadCombinedHtml(selectedArtworks, `creazioni-combinate-${Date.now()}.html`); };
        const handleStartEditing = (art) => { setEditingId(art.id); setEditingTitle(art.title); };
        const handleRename = () => { if (editingId !== null && editingTitle.trim() !== '') onRename(editingId, editingTitle.trim()); setEditingId(null); setEditingTitle(''); };
        const handleKeyDown = (event) => { if (event.key === 'Enter') handleRename(); else if (event.key === 'Escape') { setEditingId(null); setEditingTitle(''); } };
        
        const handleDragStart = (e, id) => { dragId.current = id; e.dataTransfer.effectAllowed = 'move'; };
        const handleDragOver = (e) => { e.preventDefault(); };
        const handleDrop = (e, targetId) => {
            e.preventDefault();
            if (dragId.current && dragId.current !== targetId) {
                onReorder(dragId.current, targetId);
            }
            dragId.current = null;
        };

        if (artworks.length === 0) return React.createElement("div", { className: "w-full bg-white p-6 md:p-8 rounded-xl shadow-lg border border-gray-200" }, React.createElement("p", { className: "text-center text-gray-500 py-8" }, "Le tue creazioni salvate appariranno qui."));

        return React.createElement("div", { className: "w-full bg-white p-6 md:p-8 rounded-xl shadow-lg border border-gray-200" }, React.createElement("div", { className: "flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4" }, React.createElement("h3", { className: "text-xl font-bold text-gray-900" }, "Galleria"), React.createElement("button", { onClick: handleCombineAndDownload, disabled: selectedArtworks.length < 2, className: "inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 focus:ring-offset-white disabled:bg-gray-400 disabled:cursor-not-allowed transition-all" }, React.createElement(CombineIcon, null), React.createElement("span", { className: "ml-2" }, `Combina & Scarica (${selectedArtworks.length})`))), React.createElement("div", { className: "grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6" }, artworks.map(art => React.createElement("div", { key: art.id, draggable: "true", onDragStart: (e) => handleDragStart(e, art.id), onDragOver: handleDragOver, onDrop: (e) => handleDrop(e, art.id), className: "relative group bg-gray-50 rounded-lg overflow-hidden border border-gray-200 shadow-sm flex flex-col cursor-move" }, React.createElement("div", { className: "absolute top-2 right-2 z-10 bg-white/50 backdrop-blur-sm rounded-md" }, React.createElement("input", { type: "checkbox", checked: selectedIds.has(art.id), onChange: () => handleSelect(art.id), className: "h-5 w-5 rounded text-red-600 bg-gray-100 border-gray-300 focus:ring-red-500" })), React.createElement("div", { className: "relative" }, React.createElement("img", { src: art.thumbnail, alt: art.title, className: "w-full h-40 object-cover pointer-events-none" }), React.createElement("div", { className: "absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-x-2" }, React.createElement("button", { onClick: () => onView(art), className: "text-white p-2 rounded-full bg-black/40 hover:bg-black/70 transition-colors", title: "Visualizza" }, React.createElement(ViewIcon, null)), React.createElement("button", { onClick: () => onEdit(art), className: "text-white p-2 rounded-full bg-black/40 hover:bg-black/70 transition-colors", title: "Modifica" }, React.createElement(EditIcon, null)), React.createElement("button", { onClick: () => onDelete(art.id), className: "text-white p-2 rounded-full bg-black/40 hover:bg-black/70 transition-colors", title: "Elimina" }, React.createElement(DeleteIcon, null)))), React.createElement("div", { className: "p-3 flex-grow flex flex-col justify-between" }, editingId === art.id ? React.createElement("div", { className: "flex items-center gap-2" }, React.createElement("input", { type: "text", value: editingTitle, onChange: (e) => setEditingTitle(e.target.value), onKeyDown: handleKeyDown, onBlur: handleRename, className: "text-sm font-medium text-gray-800 w-full border-gray-300 rounded-md shadow-sm p-1", autoFocus: true }), React.createElement("button", { onClick: handleRename, className: "text-gray-500 hover:text-green-600 p-1" }, React.createElement(SaveIcon, null))) : React.createElement("div", { className: "flex items-center justify-between gap-2" }, React.createElement("p", { className: "text-sm font-medium text-gray-800 truncate", title: art.title }, art.title), React.createElement("button", { onClick: () => handleStartEditing(art), className: "text-gray-400 hover:text-red-600 p-1 opacity-0 group-hover:opacity-100 transition-opacity" }, React.createElement(EditIcon, { className: "h-5 w-5" }))))))));
      };

      const UnifiedGraphEditor = ({ title, dataGroups, onTitleChange, onElementChange }) => {
        if (!title && (!dataGroups || dataGroups.length === 0)) return React.createElement("p", { className: "text-sm text-gray-500 text-center" }, "Nessun elemento modificabile trovato.");
        
        return React.createElement("div", { className: "space-y-4" },
          title && React.createElement("details", { className: "bg-gray-50 border border-gray-200 rounded-lg p-3", open: true },
            React.createElement("summary", { className: "font-semibold text-gray-800 cursor-pointer" }, "Titolo"),
            React.createElement("input", {
              type: "text",
              id: "graph-title",
              value: title,
              onChange: (e) => onTitleChange(e.target.value),
              className: "mt-2 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm p-2"
            })
          ),
          dataGroups.map(group => React.createElement("details", { key: group.name, className: "bg-gray-50 border border-gray-200 rounded-lg p-3 open:shadow-lg", open: true },
            React.createElement("summary", { className: "font-semibold text-gray-800 cursor-pointer" }, group.displayName),
            React.createElement("div", { className: "mt-4 space-y-3" },
              group.elements.map(el => React.createElement("div", { key: el.id, className: "grid grid-cols-1 md:grid-cols-6 gap-2 items-center" },
                React.createElement("input", {
                  type: "text",
                  value: el.label,
                  onChange: (e) => onElementChange(el.id, 'label', e.target.value),
                  className: "col-span-1 md:col-span-3 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm p-1.5",
                  "aria-label": `Etichetta per ${el.id}`
                }),
                React.createElement("input", {
                  type: "number",
                  value: el.value,
                  onChange: (e) => onElementChange(el.id, 'value', e.target.value),
                  className: "col-span-1 md:col-span-2 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm p-1.5",
                  "aria-label": `Valore per ${el.id}`
                }),
                React.createElement("div", { className: "relative col-span-1 md:col-span-1 h-8 w-full" },
                    React.createElement("input", {
                        type: "color",
                        value: el.color || '#000000',
                        onChange: (e) => onElementChange(el.id, 'color', e.target.value),
                        className: "absolute inset-0 w-full h-full opacity-0 cursor-pointer",
                        "aria-label": `Colore per ${el.id}`
                    }),
                    React.createElement("div", { 
                        className: "w-full h-full border border-gray-300 rounded-md flex items-center justify-center pointer-events-none",
                        style: { backgroundColor: el.color || '#000000' }
                    },
                    React.createElement(NewPaintBucketIcon, null)
                  )
                )
              ))
            )
          ))
        );
      };
      
      const GraphTypeChanger = ({ onRefine, isRefining }) => {
          const graphTypes = [
              { key: 'pie', name: 'Grafico a Torta' },
              { key: 'bar', name: 'Grafico a Barre' },
              { key: 'line', name: 'Grafico a Linee' }
          ];
          const basePrompt = "Analizzando il codice HTML corrente, estrai i dati (etichette e valori) e trasforma il grafico attuale in un [CHART_TYPE]. Mantieni gli stessi colori e dati, ma adatta la struttura HTML e lo script di aggiornamento. Riproduci tutti gli attributi `data-editable-id` e `data-value` necessari per il nuovo formato, e assicurati che l'interattività hover con tooltip funzioni.";
          
          const handleClick = (type) => {
              const prompt = basePrompt.replace('[CHART_TYPE]', `grafico a ${type === 'pie' ? 'torta' : type === 'bar' ? 'barre' : 'linee'}`);
              onRefine(prompt);
          };

          return React.createElement("div", { className: "flex flex-wrap gap-3" },
              graphTypes.map(type => React.createElement("button", {
                  key: type.key,
                  onClick: () => handleClick(type.key),
                  disabled: isRefining,
                  className: "flex-1 text-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 disabled:bg-gray-200 disabled:cursor-not-allowed"
              }, type.name))
          );
      };

      const InteractiveArtDisplay = ({ htmlContent, onSave, onRefine, onAnalyze, isRefining, isAnalyzing, analysisResult, onHtmlChange, onClose }) => {
        const [refinementPrompt, setRefinementPrompt] = useState('');
        const [editorGroups, setEditorGroups] = useState([]);
        const [graphTitle, setGraphTitle] = useState('');
        const iframeRef = useRef(null);

        const iframeContent = useMemo(() => wrapHtmlForIframe(htmlContent), [htmlContent]);

        useEffect(() => {
          if (!htmlContent) { setEditorGroups([]); setGraphTitle(''); return; }
          try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            
            const titleNode = doc.querySelector('[data-editable-id="title"]');
            setGraphTitle(titleNode ? titleNode.textContent.trim() : '');

            const visualElements = doc.querySelectorAll('[data-value]');
            const tempGroups = {};
            const friendlyNames = { bar: 'Dati Barre', slice: 'Dati Fette', point: 'Dati Punti' };

            visualElements.forEach(node => {
                const id = node.getAttribute('data-editable-id');
                if (!id) return;
                
                const baseId = id.substring(id.indexOf('-') + 1);
                const groupKey = Object.keys(friendlyNames).find(key => id.startsWith(key)) || 'data';
                
                if (!tempGroups[groupKey]) {
                    tempGroups[groupKey] = { displayName: friendlyNames[groupKey] || 'Altri Dati', elements: [] };
                }
                
                const value = node.dataset.value;
                const color = node.style.backgroundColor || node.style.fill || (node.getAttribute && node.getAttribute('fill')) || '#000000';
                const labelNode = doc.querySelector(`[data-editable-id="label-${baseId}"]`);
                const label = labelNode ? labelNode.textContent.trim() : baseId;

                tempGroups[groupKey].elements.push({ id: baseId, label, value, color });
            });
            
            setEditorGroups(Object.entries(tempGroups).map(([name, data]) => ({ name, ...data })));

          } catch (e) {
            console.error("Errore durante l'analisi dell'HTML per l'editor:", e);
            setEditorGroups([]);
            setGraphTitle('');
          }
        }, [htmlContent]);

        const updateHtmlAndTriggerRefresh = (updater) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            updater(doc);
            const scriptTag = doc.querySelector('script');
            if (scriptTag) {
                scriptTag.textContent += '\nif (typeof updateGraph === "function") { updateGraph(); }';
            }
            onHtmlChange(doc.documentElement.outerHTML);
        }

        const handleTitleChange = useCallback((newTitle) => {
            updateHtmlAndTriggerRefresh(doc => {
                const node = doc.querySelector(`[data-editable-id="title"]`);
                if (node) node.textContent = newTitle;
            });
        }, [htmlContent, onHtmlChange]);

        const handleElementChange = useCallback((baseId, property, newValue) => {
            updateHtmlAndTriggerRefresh(doc => {
                const visualNode = doc.querySelector(`[data-editable-id$="-${baseId}"]`);
                if (!visualNode) return;
                
                if (property === 'label') {
                    const node = doc.querySelector(`[data-editable-id="label-${baseId}"]`);
                    if (node) node.textContent = newValue;
                } else if (property === 'value') {
                    visualNode.dataset.value = newValue;
                } else if (property === 'color') {
                    visualNode.style.backgroundColor = newValue;
                    visualNode.style.fill = newValue;
                    if (visualNode.hasAttribute('fill')) {
                        visualNode.setAttribute('fill', newValue);
                    }
                }
            });
        }, [htmlContent, onHtmlChange]);

        const handleSave = useCallback(() => {
            onSave(htmlContent);
            onClose(); 
        }, [htmlContent, onSave, onClose]);
        
        const handleDownloadHTML = useCallback(() => downloadHtml(htmlContent, `grafico-interattivo-${Date.now()}.html`), [htmlContent]);
        const handleRefineClick = useCallback(() => { if (refinementPrompt.trim()) onRefine(refinementPrompt); }, [refinementPrompt, onRefine]);
        
        const handleExport = (format) => {
            const iframe = iframeRef.current;
            if (!iframe || !iframe.contentWindow || !iframe.contentWindow.document.body) {
                alert("Impossibile accedere al contenuto del grafico per l'esportazione.");
                return;
            }
            const targetElement = iframe.contentWindow.document.body.firstChild; // Target the first child, which is the actual chart container
            if (!targetElement) {
                alert("Contenuto del grafico non trovato.");
                return;
            }

            const filename = `grafico-${Date.now()}`;

            if (format === 'png') {
                html2canvas(targetElement, {
                    backgroundColor: null, 
                    useCORS: true,
                    logging: false
                }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = `${filename}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                });
            } else if (format === 'svg') {
                const svgElement = targetElement.querySelector('svg');
                if (svgElement) {
                    const serializer = new XMLSerializer();
                    const svgString = serializer.serializeToString(svgElement);
                    const blob = new Blob([svgString], {type: "image/svg+xml"});
                    createDownloadLink(blob, `${filename}.svg`);
                } else {
                    alert("Esportazione SVG non disponibile: nessun elemento SVG trovato nel grafico. Prova a esportare come PNG.");
                }
            }
        };

        const buttonClasses = "w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 focus:ring-offset-white transition-all disabled:bg-red-400";
        const secondaryButtonClasses = "w-full inline-flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50";

        return React.createElement("div", { className: "flex h-[calc(100vh-4rem)]" },
          React.createElement("aside", { className: "w-96 flex-shrink-0 bg-white border-r border-gray-200 h-full overflow-y-auto p-6 space-y-8" },
             React.createElement("div", { className: "space-y-4" },
                React.createElement("h3", { className: "text-xl font-bold text-gray-900" }, "Pannello di Controllo"),
                React.createElement("button", { onClick: onClose, className: "w-full flex items-center justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50" }, React.createElement(CloseEditorIcon, null), React.createElement("span", { className: "ml-2" }, "Chiudi e torna alla Galleria")),
                React.createElement(UnifiedGraphEditor, { title: graphTitle, dataGroups: editorGroups, onTitleChange: handleTitleChange, onElementChange: handleElementChange })
             ),
             React.createElement("div", { className: "border-t pt-6 space-y-4" },
                React.createElement("h4", {className: "text-lg font-semibold text-gray-800 mb-3"}, "Trasforma Grafico"),
                React.createElement(GraphTypeChanger, { onRefine: onRefine, isRefining: isRefining })
             ),
             React.createElement("div", { className: "border-t border-gray-200 pt-6 space-y-4" },
                React.createElement("h4", { className: "text-lg font-semibold text-gray-800" }, "Affina con IA (Avanzato)"),
                React.createElement("textarea", { value: refinementPrompt, onChange: (e) => setRefinementPrompt(e.target.value), disabled: isRefining, placeholder: "Es: 'aggiungi un'ombreggiatura alle barre'", className: "w-full p-3 border border-gray-300 rounded-md shadow-sm focus:ring-red-500 focus:border-red-500 transition-colors disabled:bg-gray-100", rows: 2 }),
                React.createElement("button", { onClick: handleRefineClick, disabled: isRefining || !refinementPrompt.trim(), className: "w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gray-800 hover:bg-gray-900" },
                  isRefining ? React.createElement(LoadingSpinner, { className: 'h-5 w-5' }) : React.createElement(SparklesIcon, null), React.createElement("span", { className: "ml-2" }, isRefining ? "Affinamento..." : "Affina con IA"))
             ),
             React.createElement("div", { className: "border-t border-gray-200 pt-6 space-y-4" },
                React.createElement("h4", { className: "text-lg font-semibold text-gray-800" }, "Analisi Grafico con IA"),
                React.createElement("button", { onClick: onAnalyze, disabled: isAnalyzing, className: "w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700" },
                  isAnalyzing ? React.createElement(LoadingSpinner, { className: 'h-5 w-5' }) : React.createElement(CommentIcon, null), React.createElement("span", { className: "ml-2" }, isAnalyzing ? "Analisi in corso..." : "Genera Commento")),
                analysisResult && React.createElement("div", { className: "p-3 bg-gray-50 border border-gray-200 rounded-md text-sm text-gray-700 whitespace-pre-wrap" }, analysisResult)
             ),
             React.createElement("div", { className: "border-t border-gray-200 pt-6 flex flex-col gap-4" },
                React.createElement("button", { onClick: handleSave, className: buttonClasses, disabled: isRefining }, React.createElement(SaveIcon, null), React.createElement("span", { className: "ml-2" }, "Salva e Chiudi")),
                React.createElement("button", { onClick: handleDownloadHTML, className: secondaryButtonClasses, disabled: isRefining }, React.createElement(DownloadIcon, null), React.createElement("span", { className: "ml-2" }, "Scarica HTML")),
                React.createElement("button", { onClick: () => handleExport('png'), className: secondaryButtonClasses, disabled: isRefining }, React.createElement(PngIcon, null), React.createElement("span", { className: "ml-2" }, "Esporta come PNG"))
             )
          ),
          React.createElement("main", { className: "flex-grow bg-gray-100" },
            React.createElement("iframe", { ref: iframeRef, key: htmlContent, srcDoc: iframeContent, title: "Anteprima Arte Interattiva", className: "w-full h-full border-0", sandbox: "allow-scripts allow-same-origin" })
          )
        );
      };
      
      // --- APP ---
      const App = () => {
        const [editingArtworkId, setEditingArtworkId] = useState(null);
        const [htmlContent, setHtmlContent] = useState(null);
        const [originalImage, setOriginalImage] = useState(null);
        const [artworks, setArtworks] = useState(() => {
            try {
                const savedArtworks = localStorage.getItem('graph-ai-artworks');
                return savedArtworks ? JSON.parse(savedArtworks) : [];
            } catch (error) {
                console.error("Failed to load artworks from localStorage", error);
                return [];
            }
        });
        const [isLoading, setIsLoading] = useState(false);
        const [isRefining, setIsRefining] = useState(false);
        const [isAnalyzing, setIsAnalyzing] = useState(false);
        const [analysisResult, setAnalysisResult] = useState("");
        const [error, setError] = useState(null);
        const [artIdCounter, setArtIdCounter] = useState(() => {
            const savedCounter = localStorage.getItem('graph-ai-counter');
            return savedCounter ? parseInt(savedCounter, 10) : 0;
        });
        const [viewingArtwork, setViewingArtwork] = useState(null);
        const [chat, setChat] = useState(null);
        
        useEffect(() => {
            try {
                localStorage.setItem('graph-ai-artworks', JSON.stringify(artworks));
                localStorage.setItem('graph-ai-counter', artIdCounter.toString());
            } catch (error) {
                console.error("Failed to save to localStorage", error);
            }
        }, [artworks, artIdCounter]);

        const getChat = useCallback(() => {
          if (chat) return chat;
          const apiKey = "AIzaSyAUpMnG760HSOV7rah2UwkOajoH3aD4OFs";
          const ai = new GoogleGenAI({ apiKey });
          const newChat = ai.chats.create({ model: 'gemini-2.5-flash-preview-04-17', config: { temperature: 0.1 } });
          setChat(newChat);
          return newChat;
        }, [chat]);
        
        const handleFileUpload = useCallback(async (file) => {
          setIsLoading(true);
          setError(null);
          setHtmlContent(null);
          setOriginalImage(null);
          setChat(null);
          setEditingArtworkId(null);
          setAnalysisResult("");

          try {
            let result;
            if(file.type.startsWith('image/')) {
                result = await startImageChat(file);
            } else if (['.csv', '.json'].some(ext => file.name.endsWith(ext))) {
                const fileContent = await readFileAsText(file);
                const fileType = file.name.endsWith('.csv') ? 'CSV' : 'JSON';
                result = await startDataChat(fileContent, fileType);
            } else {
                throw new Error("Tipo di file non supportato. Carica un'immagine, un CSV o un JSON.");
            }

            setHtmlContent(result.htmlContent);
            setOriginalImage(result.dataUrl);
            setChat(result.chat);
          } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Si è verificato un errore sconosciuto.';
            setError(`Impossibile elaborare il file. ${errorMessage}`);
            console.error(err);
          } finally {
            setIsLoading(false);
          }
        }, []);
        
        const handleRefine = useCallback(async (refinementPrompt) => {
          if (!refinementPrompt) return;
          setIsRefining(true);
          setError(null);
          try {
            const activeChat = getChat();
            const fullRefinementPrompt = `Basandoti sul seguente codice HTML, applica questa modifica: "${refinementPrompt}". Il codice è: \`\`\`html\n${htmlContent}\n\`\`\`. Restituisci solo il codice HTML completo e aggiornato nel solito formato markdown. Non aggiungere commenti.`;
            const response = await activeChat.sendMessage({ message: fullRefinementPrompt });
            const newHtmlContent = processApiResponse(response);
            setHtmlContent(newHtmlContent);
          } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Si è verificato un errore sconosciuto.';
            setError(`Impossibile affinare la creazione. ${errorMessage}`);
            console.error(err);
          } finally {
            setIsRefining(false);
          }
        }, [getChat, htmlContent]);
        
        const handleAnalyze = useCallback(async () => {
          setIsAnalyzing(true);
          setAnalysisResult("");
          setError(null);
          try {
            const activeChat = getChat();
            const prompt = `Agisci come un analista di dati esperto. Analizza il seguente codice HTML che rappresenta un grafico o una tabella e fornisci un breve commento sui dati mostrati. Concentrati sui punti salienti, i valori massimi o minimi, o eventuali pattern interessanti. Sii conciso e professionale. Ecco il codice: \`\`\`html\n${htmlContent}\n\`\`\``;
            const response = await activeChat.sendMessage({ message: prompt });
            setAnalysisResult(response.text.trim());
          } catch (err) {
             const errorMessage = err instanceof Error ? err.message : 'Si è verificato un errore sconosciuto.';
             setError(`Impossibile analizzare il grafico. ${errorMessage}`);
          } finally {
            setIsAnalyzing(false);
          }
        }, [getChat, htmlContent]);

        const handleSaveArtwork = useCallback((artHtml, idToUpdate) => {
            if (idToUpdate !== null) {
                setArtworks(prev => prev.map(art => 
                    art.id === idToUpdate ? { ...art, htmlContent: artHtml } : art
                ));
            } else {
                if (!originalImage) return;
                const newArtwork = { id: artIdCounter, thumbnail: originalImage, htmlContent: artHtml, title: `Creazione ${artIdCounter + 1}` };
                setArtworks(prev => [newArtwork, ...prev]);
                setArtIdCounter(prev => prev + 1);
            }
        }, [originalImage, artIdCounter]);

        const handleCloseEditor = useCallback(() => {
            setHtmlContent(null);
            setOriginalImage(null);
            setChat(null);
            setEditingArtworkId(null);
            setAnalysisResult("");
        }, []);
        
        const handleDeleteArtwork = useCallback((id) => setArtworks(prev => prev.filter(art => art.id !== id)), []);
        const handleRenameArtwork = useCallback((id, newTitle) => setArtworks(prev => prev.map(art => art.id === id ? { ...art, title: newTitle } : art)), []);
        
        const handleReorderArtworks = useCallback((draggedId, targetId) => {
            setArtworks(prev => {
                const newArtworks = [...prev];
                const draggedIndex = newArtworks.findIndex(art => art.id === draggedId);
                const targetIndex = newArtworks.findIndex(art => art.id === targetId);
                if (draggedIndex === -1 || targetIndex === -1) return prev;
                const [draggedItem] = newArtworks.splice(draggedIndex, 1);
                newArtworks.splice(targetIndex, 0, draggedItem);
                return newArtworks;
            });
        }, []);
        
        const handleEditArtwork = useCallback((artwork) => {
            setEditingArtworkId(artwork.id);
            setHtmlContent(artwork.htmlContent);
            setOriginalImage(artwork.thumbnail);
            setChat(null);
            setAnalysisResult("");
        }, []);

        if (htmlContent) {
            return React.createElement("div", { className: "min-h-screen bg-gray-100 text-gray-800 font-sans" },
                React.createElement(Header, null),
                React.createElement(InteractiveArtDisplay, {
                    htmlContent: htmlContent,
                    onSave: (artHtml) => handleSaveArtwork(artHtml, editingArtworkId),
                    onRefine: handleRefine,
                    onAnalyze: handleAnalyze,
                    isRefining: isRefining,
                    isAnalyzing: isAnalyzing,
                    analysisResult: analysisResult,
                    onHtmlChange: setHtmlContent,
                    onClose: handleCloseEditor
                })
            );
        }
        
        return React.createElement("div", { className: "min-h-screen bg-gray-100 text-gray-800 font-sans" }, 
            React.createElement(Header, null), 
            React.createElement("main", { className: "container mx-auto p-4 md:p-8" }, 
                React.createElement("div", { className: "max-w-4xl mx-auto space-y-12" }, 
                    React.createElement("div", { className: "text-center" }, 
                        React.createElement("h2", { className: "text-3xl font-bold tracking-tight text-gray-900 sm:text-4xl" }, "Graph.AI"), 
                        React.createElement("p", { className: "mt-4 text-lg leading-8 text-gray-600" }, "Trasforma i tuoi dati e le tue immagini in presentazioni interattive")
                    ), 
                    React.createElement(InputUploader, { onFileUpload: handleFileUpload, isLoading: isLoading }), 
                    isLoading && React.createElement("div", { className: "flex flex-col items-center justify-center p-8 bg-white/50 rounded-lg" }, 
                        React.createElement(LoadingSpinner, null), 
                        React.createElement("p", { className: "mt-4 text-gray-600" }, "Il tuo sviluppatore frontend AI personale sta creando la tua opera...")
                    ), 
                    error && React.createElement("div", { className: "text-center text-red-700 bg-red-100 p-4 rounded-md" }, error), 
                    React.createElement(ArtGallery, { artworks: artworks, onDelete: handleDeleteArtwork, onRename: handleRenameArtwork, onView: setViewingArtwork, onEdit: handleEditArtwork, onReorder: handleReorderArtworks })
                )
            ), 
            React.createElement(FullScreenViewer, { artwork: viewingArtwork, onClose: () => setViewingArtwork(null) })
        );
      };
      
      // --- RENDER ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(React.createElement(App, null));
    </script>
  </body>
</html>
